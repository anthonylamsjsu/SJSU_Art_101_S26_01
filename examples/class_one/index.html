<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Procedural Environment - FPS Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        #instructions h2 {
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        #instructions ul {
            list-style: none;
            padding-left: 0;
        }
        
        #instructions li {
            margin: 8px 0;
        }
        
        #instructions kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    
    <div id="instructions">
        <h2>3D Procedural Environment</h2>
        <p>Click to start exploring!</p>
        <ul>
            <li><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> - Move</li>
            <li>Mouse - Look around</li>
            <li><kbd>Space</kbd> - Jump</li>
            <li><kbd>Shift</kbd> - Run</li>
            <li><kbd>ESC</kbd> - Release mouse</li>
        </ul>
        <p style="margin-top: 10px; color: #FFC107;">Environment generates procedurally as you explore!</p>
    </div>
    
    <div id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Objects: <span id="objectCount">0</span></div>
        <div>Position: <span id="position">0, 0, 0</span></div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE8E8E8); // Light gray/white
        scene.fog = new THREE.Fog(0xE8E8E8, 0, 500);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xF0F0F0 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Procedural generation system
        const chunkSize = 50;
        const renderDistance = 150;
        const loadedChunks = new Set();
        const objects = [];

        function getChunkKey(x, z) {
            const chunkX = Math.floor(x / chunkSize);
            const chunkZ = Math.floor(z / chunkSize);
            return `${chunkX},${chunkZ}`;
        }

        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (loadedChunks.has(key)) return;
            loadedChunks.add(key);

            // Use seeded random for consistent generation
            const seed = chunkX * 73856093 ^ chunkZ * 19349663;
            const random = (seed) => {
                seed = ((seed << 13) ^ seed) >>> 0;
                return ((seed * (seed * seed * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483648.0;
            };

            const numBuildings = Math.floor(random(seed) * 5) + 2;

            for (let i = 0; i < numBuildings; i++) {
                const x = chunkX * chunkSize + (random(seed + i * 100) - 0.5) * chunkSize;
                const z = chunkZ * chunkSize + (random(seed + i * 200) - 0.5) * chunkSize;
                const height = random(seed + i * 300) * 15 + 5;
                const width = random(seed + i * 400) * 8 + 3;
                const depth = random(seed + i * 500) * 8 + 3;

                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                // Monochromatic: vary lightness only (0.2 to 0.8 for grayscale)
                const lightness = 0.2 + random(seed + i * 600) * 0.6;
                const buildingMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, lightness)
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(x, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                objects.push(building);
            }

            // Add some trees
            const numTrees = Math.floor(random(seed + 1000) * 3);
            for (let i = 0; i < numTrees; i++) {
                const x = chunkX * chunkSize + (random(seed + i * 800) - 0.5) * chunkSize;
                const z = chunkZ * chunkSize + (random(seed + i * 900) - 0.5) * chunkSize;
                
                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x404040 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, 2, z);
                trunk.castShadow = true;
                scene.add(trunk);
                objects.push(trunk);

                // Tree top
                const topGeometry = new THREE.ConeGeometry(2, 4, 8);
                const topMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.set(x, 6, z);
                top.castShadow = true;
                scene.add(top);
                objects.push(top);
            }
        }

        function updateChunks() {
            const cameraChunkX = Math.floor(camera.position.x / chunkSize);
            const cameraChunkZ = Math.floor(camera.position.z / chunkSize);
            const chunksToLoad = Math.ceil(renderDistance / chunkSize);

            for (let x = -chunksToLoad; x <= chunksToLoad; x++) {
                for (let z = -chunksToLoad; z <= chunksToLoad; z++) {
                    const distance = Math.sqrt(x * x + z * z) * chunkSize;
                    if (distance <= renderDistance) {
                        generateChunk(cameraChunkX + x, cameraChunkZ + z);
                    }
                }
            }
        }

        // FPS Controls
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isRunning = false;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();

        // Pointer lock controls
        const controls = {
            isLocked: false,
            yaw: 0,
            pitch: 0,
            sensitivity: 0.0015
        };

        const onMouseMove = (event) => {
            if (!controls.isLocked) return;

            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            controls.yaw -= movementX * controls.sensitivity;
            controls.pitch -= movementY * controls.sensitivity;
            controls.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.pitch));
        };

        const onPointerLockChange = () => {
            controls.isLocked = document.pointerLockElement === renderer.domElement ||
                               document.mozPointerLockElement === renderer.domElement ||
                               document.webkitPointerLockElement === renderer.domElement;
            
            if (controls.isLocked) {
                document.getElementById('instructions').style.display = 'none';
            }
        };

        const onPointerLockError = () => {
            console.error('Pointer lock failed');
        };

        document.addEventListener('pointerlockchange', onPointerLockChange);
        document.addEventListener('mozpointerlockchange', onPointerLockChange);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange);
        document.addEventListener('pointerlockerror', onPointerLockError);
        document.addEventListener('mozpointerlockerror', onPointerLockError);
        document.addEventListener('webkitpointerlockerror', onPointerLockError);
        document.addEventListener('mousemove', onMouseMove);

        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                    renderer.domElement.mozRequestPointerLock ||
                                                    renderer.domElement.webkitRequestPointerLock;
            renderer.domElement.requestPointerLock();
        });

        // Keyboard controls
        const onKeyDown = (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 6; break;
                case 'ShiftLeft': isRunning = true; break;
            }
        };

        const onKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // Physics and movement
        let prevTime = performance.now();
        const speed = 3.5; // Base walking speed
        const runMultiplier = 1.5; // Running speed multiplier
        const damping = 8.0; // Movement damping for smoother feel

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); // Cap delta to prevent huge jumps
            prevTime = time;

            // Update camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = controls.yaw;
            camera.rotation.x = controls.pitch;

            // Movement damping (smoother deceleration)
            velocity.x -= velocity.x * damping * delta;
            velocity.z -= velocity.z * damping * delta;
            velocity.y -= 9.8 * 10.0 * delta; // gravity

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            const currentSpeed = isRunning ? speed * runMultiplier : speed;
            
            // Apply movement input (reduced multiplier for better control)
            if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * 5.0 * delta;
            if (moveLeft || moveRight) velocity.x += direction.x * currentSpeed * 5.0 * delta; // Fixed: changed -= to += for correct strafe direction

            // Ground collision
            raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects([ground], false);
            
            if (intersects.length > 0) {
                const distance = intersects[0].distance;
                if (distance < 5) {
                    camera.position.y = 5 - distance + camera.position.y;
                    velocity.y = Math.max(0, velocity.y);
                    canJump = true;
                }
            }

            // Apply movement
            const moveVector = new THREE.Vector3();
            moveVector.set(velocity.x * delta, velocity.y * delta, velocity.z * delta);
            moveVector.applyQuaternion(camera.quaternion);
            camera.position.add(moveVector);

            // Keep camera above ground
            if (camera.position.y < 5) {
                camera.position.y = 5;
                velocity.y = 0;
                canJump = true;
            }

            // Update procedural chunks
            updateChunks();

            // Render
            renderer.render(scene, camera);

            // Update stats
            document.getElementById('fps').textContent = Math.round(1 / delta);
            document.getElementById('objectCount').textContent = objects.length;
            document.getElementById('position').textContent = 
                `${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
