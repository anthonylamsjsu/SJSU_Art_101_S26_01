<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DIGITAL RESIDUE — Visualization</title>
  <link rel="stylesheet" href="./style.css?v=1009">
</head>

<body data-page="viz">

<a class="back" href="./index.html">← BACK</a>

<h1 class="viz-title">MY SCREEN TIME</h1>
<p class="viz-sub">TAP / CLICK A COLOR BLOB TO REVEAL THE APP + SCREENTIME.</p>

<div id="blob-stage"></div>
<div id="tip" class="tip"></div>

<script src="./data.js?v=1009"></script>

<script>
const stage = document.getElementById("blob-stage");
const tip = document.getElementById("tip");
const ITEMS = (typeof APPS !== "undefined") ? APPS : [];

if (!ITEMS.length) {
  stage.innerHTML = `<p style="opacity:.7">No APPS data found in data.js.</p>`;
} else {

  /* ===== TUNING ===== */
  const PAD = 24;
  const GAP = 260;
  const SOLVER_PASSES = 10;

  /* CHANGED — softer physics */
  const SEPARATE_RATIO = 0.35;   // was 0.72 (this caused darting)
  const REPEL = 0.012;           // was 0.030 (too aggressive)
  const DAMP = 0.994;            // smoother float
  const BOUNCE = 0.92;           // less harsh wall bounce
  const DRIFT = 0.060;           // calmer roaming
  const MAX_SPEED = 3.2;         // prevents sudden speed spikes
  const ACTIVE_REPEL = 1.25;     // gentle push, not explosion

  const VISUAL_GAP = 28;

  const maxH = Math.max(...ITEMS.map(x => Number(x.hours || 0)), 1);

  const blobs = [];
  const placed = [];
  let activeIndex = -1;

  function showTip(text, x, y){
    tip.textContent = text;
    tip.style.opacity = "1";
    tip.style.left = (x + 14) + "px";
    tip.style.top  = (y + 14) + "px";
  }

  function hideTip(){
    tip.style.opacity = "0";
  }

  function tryPlace(sizePx){
    const rect = stage.getBoundingClientRect();
    const r = sizePx/2;

    const minX = PAD;
    const minY = PAD;
    const maxX = rect.width  - sizePx - PAD;
    const maxY = rect.height - sizePx - PAD;

    for (let attempt = 0; attempt < 2400; attempt++){
      const x = minX + Math.random() * Math.max(maxX - minX, 1);
      const y = minY + Math.random() * Math.max(maxY - minY, 1);

      const cx = x + r;
      const cy = y + r;

      let ok = true;
      for (const p of placed){
        const dist = Math.hypot(cx - p.cx, cy - p.cy);
        const minDist = r + p.r + GAP + VISUAL_GAP;
        if (dist < minDist){ ok=false; break; }
      }

      if (ok){
        placed.push({cx, cy, r});
        return {x, y};
      }
    }

    return {
      x: minX + Math.random() * Math.max(maxX - minX, 1),
      y: minY + Math.random() * Math.max(maxY - minY, 1),
    };
  }

  function setActive(idx, clientX, clientY){
    activeIndex = idx;
    showTip(blobs[idx].label, clientX, clientY);

    document.querySelectorAll(".blob").forEach(b => b.classList.add("dim"));
    blobs[idx].el.classList.remove("dim");
    blobs[idx].el.classList.add("active");
  }

  function clearActive(){
    activeIndex = -1;
    hideTip();
    document.querySelectorAll(".blob").forEach(b => b.classList.remove("dim","active"));
  }

  /* ===== BUILD BLOBS ===== */
  ITEMS.forEach((item, idx) => {

    const h = Number(item.hours || 0);
    const size = 240 + (h/maxH) * 360;
    const r = size/2;

    const el = document.createElement("div");
    el.className = "blob";
    el.style.width = size + "px";
    el.style.height = size + "px";
    el.style.background =
      `radial-gradient(circle, ${item.color} 0%, rgba(255,255,255,0) 68%)`;

    stage.appendChild(el);

    const pos = tryPlace(size);

    blobs.push({
      el,
      size,
      r,
      x: pos.x,
      y: pos.y,
      vx: (Math.random()-0.5) * 2.0,
      vy: (Math.random()-0.5) * 2.0,
      phase: Math.random() * Math.PI * 2,
      speed: 0.006 + Math.random() * 0.010,
      label: `${item.app} — ${h.toFixed(1)} HOURS`
    });

    /* CLICK / TAP ONLY (removed hover auto-trigger) */
    el.addEventListener("pointerdown",(e)=>{
      e.preventDefault();
      e.stopPropagation();
      setActive(idx, e.clientX, e.clientY);
    });
  });

  document.addEventListener("mousemove",(e)=>{
    if (tip.style.opacity !== "1") return;
    tip.style.left=(e.clientX+14)+"px";
    tip.style.top =(e.clientY+14)+"px";
  });

  stage.addEventListener("pointerdown",(e)=>{
    if (e.target === stage) clearActive();
  });

  /* ===== PHYSICS LOOP ===== */
  function animate(){

    const rect = stage.getBoundingClientRect();

    blobs.forEach(o=>{
      o.phase += o.speed;
      o.vx += Math.cos(o.phase) * DRIFT;
      o.vy += Math.sin(o.phase*1.21) * DRIFT;

      const sp = Math.hypot(o.vx,o.vy);
      if(sp>MAX_SPEED){
        const s = MAX_SPEED/sp;
        o.vx*=s; o.vy*=s;
      }
    });

    for(let pass=0; pass<SOLVER_PASSES; pass++){
      for(let i=0;i<blobs.length;i++){
        for(let j=i+1;j<blobs.length;j++){

          const a=blobs[i];
          const b=blobs[j];

          const ax=a.x+a.r;
          const ay=a.y+a.r;
          const bx=b.x+b.r;
          const by=b.y+b.r;

          const dx=bx-ax;
          const dy=by-ay;
          const dist=Math.hypot(dx,dy)||0.0001;

          const activeBoost =
            (i===activeIndex||j===activeIndex)?ACTIVE_REPEL:1;

          const minDist=(a.r+b.r)+(GAP+VISUAL_GAP)*activeBoost;

          if(dist<minDist){

            const overlap=minDist-dist;
            const ux=dx/dist;
            const uy=dy/dist;

            const sep=overlap*SEPARATE_RATIO*0.5;
            a.x-=ux*sep; a.y-=uy*sep;
            b.x+=ux*sep; b.y+=uy*sep;

            const force=overlap*REPEL;
            a.vx-=ux*force; a.vy-=uy*force;
            b.vx+=ux*force; b.vy+=uy*force;
          }
        }
      }
    }

    blobs.forEach(o=>{

      o.vx*=DAMP;
      o.vy*=DAMP;

      o.x+=o.vx;
      o.y+=o.vy;

      const minX=PAD;
      const minY=PAD;
      const maxX=rect.width-o.size-PAD;
      const maxY=rect.height-o.size-PAD;

      if(o.x<minX){o.x=minX;o.vx=Math.abs(o.vx)*BOUNCE;}
      if(o.x>maxX){o.x=maxX;o.vx=-Math.abs(o.vx)*BOUNCE;}
      if(o.y<minY){o.y=minY;o.vy=Math.abs(o.vy)*BOUNCE;}
      if(o.y>maxY){o.y=maxY;o.vy=-Math.abs(o.vy)*BOUNCE;}

      o.el.style.transform=`translate(${o.x}px,${o.y}px)`;
    });

    requestAnimationFrame(animate);
  }

  animate();
}
</script>

</body>
</html>
