<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scroll â€” Sam Leavitt</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
      overflow-x: hidden;
    }

    /* Spacer to make page scrollable; total scroll height drives the story */
    .scroll-spacer {
      height: 420vh;
    }

    .stage {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      pointer-events: none;
    }
    .stage * {
      pointer-events: none;
    }

    /* "scroll down" hint â€” floats up as it fades */
    .scroll-hint {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translate(-50%, 0);
      color: #333;
      font-size: 2rem;
      letter-spacing: 0.2em;
      text-transform: lowercase;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    .scroll-hint.visible {
      opacity: 1;
    }
    .scroll-hint.faded {
      opacity: 0;
      transition: opacity 0.7s ease;
    }

    .dots-container {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      contain: layout style;
    }
    .white-mass {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 280px;
      height: 280px;
      border-radius: 50%;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .white-mass-emoji {
      font-size: 140px;
      line-height: 1;
    }

    .dot {
      position: absolute;
      left: 0;
      top: 0;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s ease;
      contain: layout style paint;
    }
    .dot.visible {
      opacity: 1;
    }

    /* Final text block */
    .final-text {
      position: absolute;
      left: 50%;
      bottom: 15vh;
      transform: translateX(-50%);
      width: min(88vw, 36rem);
      text-align: center;
      opacity: 0;
      transition: opacity 1.2s ease 0.3s;
      line-height: 1.6;
      font-size: clamp(0.95rem, 2.2vw, 1.15rem);
      font-weight: 300;
      color: rgba(255, 255, 255, 0.9);
    }
    .final-text.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="scroll-spacer"></div>

  <div class="stage">
    <p class="scroll-hint" id="scroll-hint" aria-hidden="true">scroll down</p>
    <div class="dots-container" id="dots-container">
      <!-- Dots injected by JS -->
    </div>
    <div class="white-mass" id="white-mass">
      <span class="white-mass-emoji" aria-hidden="true">ðŸ’ª</span>
    </div>
    <p class="final-text" id="final-text" aria-hidden="true">
      Each mote of light is one workout. All the workouts over time combine to form my body.
    </p>
  </div>

  <script>
    (function () {
      const scrollHint = document.getElementById('scroll-hint');
      const dotsContainer = document.getElementById('dots-container');
      const whiteMass = document.getElementById('white-mass');
      const finalText = document.getElementById('final-text');

      // Show "scroll down" after 2 seconds
      setTimeout(function () {
        scrollHint.classList.add('visible');
      }, 2000);

      function getTotalHeight() {
        return document.documentElement.scrollHeight - window.innerHeight;
      }
      const SEGMENTS = {
        hintFadeEnd: 0.03,
        dotsStart: 0.04,
        starsEnd: 0.42,      // stars appear gradually over longer scroll range
        dotsEnd: 0.58,       // coalesce finished, arm formed
        armToTopEnd: 0.72,
        textVisible: 0.75
      };

      function getScrollProgress() {
        return Math.min(1, window.scrollY / Math.max(1, getTotalHeight()));
      }

      // Pointillism: pixel grid inside arm shape (each dot = one pixel)
      function getFilledArmPoints() {
        const points = [];
        const gridRes = 22;
        const isInFill = pathEl && typeof pathEl.isPointInFill === 'function';
        for (let gy = 0; gy < gridRes; gy++) {
          for (let gx = 0; gx < gridRes; gx++) {
            const u = (gx + 0.5) / gridRes;
            const v = (gy + 0.5) / gridRes;
            const inside = isInFill ? pathEl.isPointInFill(new DOMPoint(u * 100, v * 100)) : pointInArm(u, v);
            if (inside) {
              points.push({ x: u, y: v, shade: getShadeForPoint(u, v) });
            }
          }
        }
        return points.length > 50 ? points : fallbackFilledPoints();
      }
      function pointInArm(u, v) {
        const x = u * 100;
        const y = v * 100;
        const poly = [[26,6],[38,4],[48,8],[54,16],[60,24],[68,34],[68,44],[66,54],[60,66],[52,78],[44,88],[34,94],[26,96],[18,96],[14,90],[14,82],[14,74],[16,64],[18,52],[20,40],[22,28],[24,18],[25,12],[26,8],[26,6]];
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i][0], yi = poly[i][1];
          const xj = poly[j][0], yj = poly[j][1];
          if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;
        }
        return inside;
      }
      function getShadeForPoint(u, v) {
        const cx = 0.5, cy = 0.48;
        const dist = Math.sqrt((u - cx) * (u - cx) + (v - cy) * (v - cy));
        const bicepPeak = (u > 0.5 && u < 0.68 && v > 0.3 && v < 0.55) ? 0.35 : 0;
        return Math.min(1, 0.35 + 0.4 * (1 - dist * 1.2) + bicepPeak);
      }
      function fallbackFilledPoints() {
        const points = [];
        const gridRes = 22;
        for (let gy = 0; gy < gridRes; gy++) {
          for (let gx = 0; gx < gridRes; gx++) {
            const u = (gx + 0.5) / gridRes;
            const v = (gy + 0.5) / gridRes;
            if (pointInArm(u, v)) points.push({ x: u, y: v, shade: getShadeForPoint(u, v) });
          }
        }
        return points;
      }

      const armPositions = (function () {
        const pts = getFilledArmPoints();
        if (pts.length === 0 || !pts[0].shade) return fallbackFilledPoints();
        return pts;
      })();
      const dotsData = armPositions.map(function (arm, i) {
        const starSize = 2 + Math.random() * 10;
        const sizeNorm = (starSize - 2) / 10;
        const starR = Math.round(28 + (255 - 28) * sizeNorm);
        const starG = Math.round(40 + (248 - 40) * sizeNorm);
        const starB = Math.round(75 + (220 - 75) * sizeNorm);
        const armShade = arm.shade != null ? arm.shade : 0.7;
        return {
          starX: Math.random(),
          starY: Math.random(),
          armX: arm.x,
          armY: arm.y,
          starSize: starSize,
          starColor: { r: starR, g: starG, b: starB },
          armR: Math.round(140 + 110 * armShade),
          armG: Math.round(120 + 110 * armShade),
          armB: Math.round(140 + 95 * armShade)
        };
      });
      let dotElements = [];

      function createDots() {
        const frag = document.createDocumentFragment();
        const w = window.innerWidth;
        const h = window.innerHeight;
        dotsData.forEach(function (d, i) {
          const dot = document.createElement('div');
          dot.className = 'dot';
          dot.dataset.i = i;
          dot.style.cssText = 'width:' + d.starSize + 'px;height:' + d.starSize + 'px;background:rgb(' + d.starColor.r + ',' + d.starColor.g + ',' + d.starColor.b + ');transform:translate(' + (d.starX * w) + 'px,' + (d.starY * h) + 'px) translate(-50%,-50%)';
          frag.appendChild(dot);
        });
        dotsContainer.appendChild(frag);
        dotElements = dotsContainer.querySelectorAll('.dot');
      }
      createDots();

      let boxCache = null;
      let boxCacheW = 0;
      let boxCacheH = 0;
      function getArmBoxViewportPct() {
        const w = window.innerWidth, h = window.innerHeight;
        if (boxCache && boxCacheW === w && boxCacheH === h) return boxCache;
        const rect = armContainer.getBoundingClientRect();
        boxCache = {
          left: 100 * rect.left / w,
          top: 100 * rect.top / h,
          width: 100 * rect.width / w,
          height: 100 * rect.height / h
        };
        boxCacheW = w;
        boxCacheH = h;
        return boxCache;
      }

      function easeInCubic(t) {
        return t * t * t;
      }
      function easeOutQuad(t) {
        return 1 - (1 - t) * (1 - t);
      }
      function starsAppearProgress(scrollProgress) {
        if (scrollProgress <= SEGMENTS.dotsStart) return 0;
        if (scrollProgress >= SEGMENTS.starsEnd) return 1;
        const t = (scrollProgress - SEGMENTS.dotsStart) / (SEGMENTS.starsEnd - SEGMENTS.dotsStart);
        return easeOutQuad(t);
      }
      function coalesceProgress(scrollProgress) {
        if (scrollProgress <= SEGMENTS.starsEnd) return 0;
        if (scrollProgress >= SEGMENTS.dotsEnd) return 1;
        return (scrollProgress - SEGMENTS.starsEnd) / (SEGMENTS.dotsEnd - SEGMENTS.starsEnd);
      }

      function update() {
        const p = getScrollProgress();

        const hintT = Math.min(1, p / SEGMENTS.hintFadeEnd);
        scrollHint.style.transform = 'translate(-50%, ' + (-90 * hintT) + 'px)';
        if (p <= SEGMENTS.hintFadeEnd) {
          scrollHint.classList.toggle('visible', hintT < 1);
          scrollHint.classList.toggle('faded', hintT >= 1);
        } else {
          scrollHint.classList.remove('visible');
          scrollHint.classList.add('faded');
        }

        const starProg = starsAppearProgress(p);
        const coalProg = coalesceProgress(p);
        const visibleCount = Math.floor(starProg * dotElements.length);
        const box = getArmBoxViewportPct();
        const w = window.innerWidth;
        const h = window.innerHeight;
        const baseSize = 5;

        for (let i = 0; i < dotElements.length; i++) {
          const dot = dotElements[i];
          const vis = i < visibleCount;
          dot.classList.toggle('visible', vis);
          if (!vis) continue;
          const d = dotsData[i];
          const xPct = (1 - coalProg) * d.starX + coalProg * (box.left / 100 + d.armX * box.width / 100);
          const yPct = (1 - coalProg) * d.starY + coalProg * (box.top / 100 + d.armY * box.height / 100);
          const puzzleSize = baseSize;
          const size = (1 - coalProg) * d.starSize + coalProg * puzzleSize;
          const r = (1 - coalProg) * d.starColor.r + coalProg * d.armR | 0;
          const g = (1 - coalProg) * d.starColor.g + coalProg * d.armG | 0;
          const b = (1 - coalProg) * d.starColor.b + coalProg * d.armB | 0;
          dot.style.transform = 'translate(' + (xPct * w) + 'px,' + (yPct * h) + 'px) translate(-50%,-50%)';
          dot.style.width = size + 'px';
          dot.style.height = size + 'px';
          dot.style.background = 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        const armAtTop = p >= SEGMENTS.armToTopEnd;
        const textVisible = p >= SEGMENTS.textVisible;
        armContainer.classList.toggle('at-top', armAtTop);
        finalText.classList.toggle('visible', textVisible);
      }

      let rafId = null;
      function onScroll() {
        if (rafId) return;
        rafId = requestAnimationFrame(function () {
          rafId = null;
          update();
        });
      }
      function onResize() {
        boxCache = null;
        update();
      }
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onResize);
      update();
    })();
  </script>
</body>
</html>
